#1.Здійснити аналіз речення Kim arrived or Dana left and everyone cheered.
#Знайти частини речення які охоплюють сполучники and та or. Побудувати дерева, які відповідають цим двом інтерпретаціям.
import nltk
grammar = nltk.parse_cfg(""" 
S -> NP VP
NP -> VP PP
VP -> N V
N -> "Anna"     
V -> "walks"
PP -> P VP
P -> "or"
VP -> N V
N -> "Peter"
V -> "drives"
VP -> PP VP
PP -> P
P -> "and"
VP -> N  V
N -> "nobody"
V -> "laught"
""")
sent = "Anna walks or Peter drives and nobody laught".split()
rd_parser = nltk.RecursiveDescentParser(grammar)
for tree in rd_parser.nbest_parse(sent):
	print tree
import nltk
grammar1 = nltk.parse_cfg("""
S -> NP VP
NP -> VP PP
VP -> N V
N -> "Anna"     
V -> "walks"
PP -> P VP
P -> "or"
VP -> N V
N -> "Peter"
V -> "drives"
VP -> PP VP
PP -> P
P -> "and"
VP -> N  V
N -> "nobody"
V -> "laught"
""")
sent = "Anna walks or Peter drives and nobody laught".split()
parser = nltk.ChartParser(grammar)
trees = parser.nbest_parse(sent)
for tree in trees:
    tree.draw()
grammar = nltk.parse_cfg("""
S -> NP VP
NP -> VP PP
VP -> N V
N -> "Anna"     
V -> "walks"
PP -> P VP
P -> "or"
VP -> N V
N -> "Peter"
V -> "drives"
VP -> PP VP
PP -> P
P -> "and"
VP -> N  V
N -> "nobody"
V -> "laught"
""")
sent = "Anna walks or Peter drives and nobody laught".split()
parser = nltk.ChartParser(grammar)
trees = parser.nbest_parse(sent)
for tree in trees:
	tree.draw()

#2. В класі Tree реалізовано різноманітні корисні методи. Переглянути файл допомоги  Tree з документації та описати основні з цих методів (import Tree,  help(Tree).
import nltk
from nltk import Tree
print help(Tree)
#Викликавши файл допомоги Tree, видно, що основним методом є chomsky_normal_form, оскільки його інтерпретації зустрічаються частіше, ніж інших методів (наприклад, un_chomsky_normal_form), а також parse(cls, s, brackets='()', parse_node=None, parse_leaf=None, node_pattern=None, leaf_pattern=None, remove_empty_top_bracketing=False).
#4.Перетворити всі дерева , які зустрічаються в методичних вказівка і зображені за допомогою дужок використовуючи  nltk.Tree() . Використовувати draw() для побудови графічного зображення дерева.
import nltk
groucho_grammar = nltk.parse_cfg("""
S -> NP VP
PP -> P NP
NP -> Det N | Det N PP | 'I'
VP -> V NP | VP PP
Det -> 'an' | 'my'
N -> 'elephant' | 'pajamas'
V -> 'shot'
P -> 'in'	
""")
sent = ['I', 'shot', 'an', 'elephant', 'in', 'my', 'pajamas']
parser = nltk.ChartParser(groucho_grammar)
trees = parser.nbest_parse(sent)
for tree in trees:
    tree.draw()

grammar1 = nltk.parse_cfg("""
S -> NP VP
VP -> V NP | V NP PP
PP -> P NP
V -> "saw" | "ate" | "walked"
NP -> "John" | "Mary" | "Bob" | Det N | Det N PP
Det -> "a" | "an" | "the" | "my"
N -> "man" | "dog" | "cat" | "telescope" | "park"
P -> "in" | "on" | "by" | "with"
""")

sent = "Mary saw Bob".split()
rd_parser = nltk.RecursiveDescentParser(grammar1)
for tree in rd_parser.nbest_parse(sent):
    tree.draw()

grammar1 = nltk.parse_cfg("""
S -> NP VP
NP -> Det N
Det -> "the"
N -> "dog"
VP -> V NP
V -> "saw"
NP -> Det N PP
Det -> "a"
N -> "man"
PP -> P NP
P -> "in"
NP -> Det N
Det -> "the"
N -> "park"
""")
sent = "the dog saw a man in the park ".split()
parser = nltk.ChartParser(grammar1)
trees = parser.nbest_parse(sent)
for tree in trees:
    tree.draw()

grammar2 = nltk.parse_cfg("""
S  -> NP VP
NP -> Det Nom | PropN
Nom -> Adj Nom | N
VP -> V Adj | V NP | V S | V NP PP
PP -> P NP
PropN -> 'Buster' | 'Chatterer' | 'Joe'
Det -> 'the' | 'a'
N -> 'bear' | 'squirrel' | 'tree' | 'fish' | 'log'
Adj  -> 'angry' | 'frightened' |  'little' | 'tall'
V ->  'chased'  | 'saw' | 'said' | 'thought' | 'was' | 'put'
P -> 'on'
""")
sent = "the angry bear chased the frightened little squirrel ".split()
parser = nltk.ChartParser(grammar2)
trees = parser.nbest_parse(sent)
for tree in trees:
    tree.draw()

grammar3 = nltk.parse_cfg("""
S  -> NP VP
NP -> Det Nom | PropN
Nom -> Adj Nom | N
VP -> V Adj | V NP | V S | V NP PP
PP -> P NP
PropN -> 'Buster' | 'Chatterer' | 'Joe'
Det -> 'the' | 'a'
N -> 'bear' | 'squirrel' | 'tree' | 'fish' | 'log'
Adj  -> 'angry' | 'frightened' |  'little' | 'tall'
V ->  'chased'  | 'saw' | 'said' | 'thought' | 'was' | 'put'
P -> 'on'
""")
sent = "Chatterer said Buster thought the tree was tall".split()
parser = nltk.ChartParser(grammar3)
trees = parser.nbest_parse(sent)
for tree in trees:
    tree.draw()

grammar4 = nltk.parse_cfg("""
S  -> NP VP
NP -> "John"
VP -> V NP
V -> "saw"
NP -> "Mary"
""")
sent = "John saw Mary".split()
parser = nltk.ChartParser(grammar4)
trees = parser.nbest_parse(sent)
for tree in trees:
    tree.draw()         
                                                                                                                                                         
groucho_grammar = nltk.parse_cfg("""
S -> NP VP
NP -> Det Nom | V  NP
Nom -> Adj N | Adj Adj N | N
VP -> NP PP
PP -> P NP
Det -> 'the'
Adj -> 'little' | 'fine' | 'fat'
N -> 'bear' | 'trout' | 'brook'
V -> 'saw'
P -> 'in'
""")
sent = "the little bear saw the fine fat trout in the brook".split()
rd_parser = nltk.RecursiveDescentParser(groucho_grammar)
for tree in rd_parser.nbest_parse(sent):
    tree.draw()
#9. Використовуючи ручку і папір, здійснити всі кроки роботи аналізаторів
#Рекурсивного спуску та переміщення згортання для довільного речення
#використовуючи просту контексно-вільну граматику.
import nltk
from nltk.parse import ShiftReduceParser
grammar = nltk.parse_cfg("""
S -> NP VP
PP -> P NP
NP -> Det N | Det N PP | 'I'
VP -> V NP | VP PP
Det -> 'a'
N -> 'cake'
V -> 'want'	
""")
sp_parse=nltk.ShiftReduceParser(grammar)
sent = "I want a cake".split()
print sp_parse.parse(sent)
#10. Здійснити аналіз послідовності слів: Buffalo buffalo Buffalo buffalo
#buffalo buffalo Buffalo buffalo. Оскільки,згідно з
#http://en.wikipedia.org/wiki/Buffalo_buffalo_Buffalo_buffalo_buffalo_buffalo_B
#ffalo_buffalo це граматично правильне речення, напишіть контексно-вільну
#граматику на основі дерева наведеного на цій сторінці з Інтернету. Здійсніть
#нормалізацію слів (lowercase), для моделювання ситуації коли слухач
#сприймає це речення на слух. Скільки дерев розбору може мати це дерево в
#такому випадку? 
import nltk
Bufalo_grammar = nltk.parse_cfg("""
S -> NP VP
NP -> NP RC | PN N
VP -> V NP
RC -> NP V
PN -> 'Buffalo'
N -> 'buffalo'
V -> 'buffalo'
""")
sent = "Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo".split()
parser = nltk.ChartParser(Bufalo_grammar)
trees = parser.nbest_parse(sent)
for tree in trees:
    tree.draw()
r="Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo"
print r.lower()
#12 Написати програму порівняння швидкодії всіх аналізаторів, які згадувалися в методичних. Використовувати timeit функцію для визначення часу синтаксичного аналізу одного і того самого речення різними аналізаторами.
import nltk.corpus
grammar=nltk.parse_cfg("""
S -> NP VP
PP -> P NP
NP -> Det N | Det N PP | 'I'
VP -> V NP | VP PP
Det -> 'a'
N -> 'cake'
V -> 'want'	
""")
recur=nltk.RecursiveDescentParser(grammar)
shf=nltk.ShiftReduceParser(grammar)
sent="I want a cake".split()
def test1(sent,parser):
    import time
    start=time.clock()
    print parser.parse(sent)
    return time.clock()-start
test1(sent,recur)
test1(sent,shf)
import timeit
t1 = timeit.Timer(setup='from nltk import RecursiveDescentParser ')
print t1.timeit()
t2 = timeit.Timer(setup='from nltk import ShiftReduceParser')
print t2.timeit()




