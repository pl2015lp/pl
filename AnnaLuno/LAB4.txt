# -*- coding: cp1251 -*-
#Variant 8
import nltk
#3.2. Використовуючи компаративний словник знайти близькі слова для німецької, італійської та англійської мов.
#Чи можуть отримані результати використовуватися для здійснення перекладу?
from nltk.corpus import swadesh
swadesh.fileids()
de2it2en=swadesh.entries(['de','it','en'])
print de2it2en
print ###################################
#3.3. Побудувати умовний частотний розподіл для корпусу імен.
#Знайти які перші літери частіше використовуються в чоловічих та жіночих іменах.
from nltk.corpus import names
cfd = nltk.ConditionalFreqDist(
		(fileid, name[0])
		for fileid in names.fileids()
		for name in names.words(fileid))
print cfd.tabulate()
print #####################################
#3.4. Здійснити аналіз словника вимов. Знайти скільки різних слів він містить.
#Який відсоток слів з цього словника можуть мати різну вимову?
from nltk.corpus import cmudict
entries=cmudict.entries()
len(entries)
vocab=[w for w, pron in entries]
len(vocab)
fdist=nltk.FreqDist(vocab)
dd=[w for w in vocab if fdist[w]>1]
percentage = (len(dd)* 100)/len(vocab)
print(percentage)
print #####################################
#3.8. Модифікувати програму генерації випадкового тексту для виконання наступного: тренувати програму на текстах різних жанрів та різних корпусів.
#Генерацію тексту провести з 5-ма різними початковими словами.
#Результати проаналізувати та порівняти.
from nltk.corpus import brown
print brown.categories()
brown.words(categories='adventure')
def generate_model(cfdist, word, num=20):
	for i in range(num):
		print word,
		word = cfdist[word].max()
text=brown.words(categories='adventure')
bigrams = nltk.bigrams(text)
cfd = nltk.ConditionalFreqDist(bigrams)
print cfd['The']
print 'First random text'
print generate_model(cfd, 'The')
text1=brown.words(categories='belles_lettres')
bigrams1 = nltk.bigrams(text)
cfd = nltk.ConditionalFreqDist(bigrams1)
print cfd['There']
print 'Second random text'
print generate_model(cfd, 'There')
text2=brown.words(categories='editorial')
bigrams2 = nltk.bigrams(text1)
cfd = nltk.ConditionalFreqDist(bigrams2)
print cfd['This']
print 'Third random text'
print generate_model(cfd, 'This')
from nltk.corpus import gutenberg
print gutenberg.fileids()
text3=gutenberg.words('austen-emma.txt')
bigrams3 = nltk.bigrams(text3)
cfd = nltk.ConditionalFreqDist(bigrams3)
print cfd['Emma']
print 'Fourth random text'
print generate_model(cfd, 'Emma')
text4=gutenberg.words('austen-persuasion.txt')
bigrams4 = nltk.bigrams(text4)
cfd = nltk.ConditionalFreqDist(bigrams4)
print cfd['How']
print 'Fifth random text'
print generate_model(cfd, 'How')
#3.13. Полісемія - це явище коли одне слово має декілька значень ( іменник dog має 7 значень, кількість яких визначити можна як len(wn.synsets('dog', 'n'))).
#Знайдіть середнє значення полісемії для прислівників.
from nltk.corpus import wordnet as wn
len(wn.synsets('dog','n'))
d=[]
for i in wn.all_synsets('r'):
        for j in i.lemma_names:
                d.append(j)
fd=nltk.FreqDist(d)
poly_adv=len(fd)/len(fd.keys())
print poly_adv
print #####################################
#3.17. Використовуючи один з методів визначення подібності слів побудуйте відсортований по спаданню список значень подібності для наступних пар слів:
#monk-oracle, cemetery-woodland, food-rooster, coast-hill, forest-graveyard, crane-implement, journey-car, coast-shore, asylum-madhouse, magician-wizard, midday-noon, furnace-stove, food-fruit, bird-cock.
from nltk.corpus import wordnet as wn
monk = wn.synset('monk.n.01')
oracle = wn.synset('oracle.n.01')
q=monk.path_similarity(oracle)
print 'monk-oracle'
print q
cemetery = wn.synset('cemetery.n.01')
woodland = wn.synset('woodland.n.01')
q1=cemetery.path_similarity(woodland)
print 'cemetery-woodland'
print q1
food = wn.synset('food.n.01')
rooster=wn.synset('rooster.n.01')
q2=food.path_similarity(rooster)
print 'food-rooster'
print q2
coast = wn.synset('coast.n.01')
hill = wn.synset('hill.n.01')
q3=coast.path_similarity(hill)
print 'coast-hill'
print q3
forest = wn.synset('forest.n.01')
graveyard = wn.synset('graveyard.n.01')
q4=forest.path_similarity(graveyard)
print 'forest-graveyard'
print q4
crane = wn.synset('crane.v.01')
implement = wn.synset('implement.v.01')
q5=crane.path_similarity(implement)
print 'crane-implement'
print q5
journey = wn.synset('journey.n.01')
car = wn.synset('car.n.01')
q6=journey.path_similarity(car)
print 'journey-car'
print q6
coast = wn.synset('coast.n.01')
shore = wn.synset('shore.n.01')
q7=coast.path_similarity(shore)
print 'coast-shore'
print q7
asylum = wn.synset('asylum.n.01')
madhouse = wn.synset('madhouse.n.01')
q8=asylum.path_similarity(madhouse)
print 'asylum-madhouse'
print q8
magician = wn.synset('magician.n.01')
wizard = wn.synset('wizard.n.01')
q9=magician.path_similarity(wizard)
print 'magician-wizard'
print q9
midday = wn.synset('midday.n.01')
noon = wn.synset('noon.n.01')
q10=midday.path_similarity(noon)
print 'midday-noon'
print q10
furnace = wn.synset('furnace.n.01')
stove = wn.synset('stove.n.01')
q11=furnace.path_similarity(stove)
print 'furnace-stove'
print q11
food = wn.synset('food.n.01')
fruit = wn.synset('fruit.n.01')
q12=food.path_similarity(fruit)
print 'food-fruit'
print q12
bird = wn.synset('bird.n.01')
cock = wn.synset('cock.n.01')
q13=bird.path_similarity(cock)
print 'bird-cock'
print q13
s=[]
s.append(q)
s.append(q1)
s.append(q2)
s.append(q3)
s.append(q4)
s.append(q5)
s.append(q6)
s.append(q7)
s.append(q8)
s.append(q9)
s.append(q10)
s.append(q11)
s.append(q12)
s.append(q13)
print s
s.sort()
print 'sortovane po zrostanniu'
print s
s.reverse()
print 'sortovane po spadanniu'
print s
