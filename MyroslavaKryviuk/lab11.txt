1.	Здійснити аналіз речення Kim arrived or Dana left and everyone cheered. Знайти частини речення які охоплюють сполучники and та or. Побудувати дерева, які відповідають цим двом інтерпретаціям.
import nltk
grammar = nltk.parse_cfg("""
S -> CP | VP
CP -> VP C VP | CP C VP | VP C CP
VP -> NP V
NP -> 'Kim' | 'Dana' | 'everyone'
V -> 'arrived' | 'left' |'cheered'
C -> 'or' | 'and'
""")

print "======= Kim arrived ========="
sent = "Kim arrived".split()
parser = nltk.ChartParser(grammar)
for t in parser.nbest_parse(sent):
    print t

print "\n======= Kim arrived or Dana left ========="
sent = "Kim arrived or Dana left".split()
parser = nltk.ChartParser(grammar)
for t in parser.nbest_parse(sent):
    print t

print "\n=== Kim arrived or Dana left and everyone cheered ===="
sent = "Kim arrived or Dana left and everyone cheered".split()
parser = nltk.ChartParser(grammar)
for t in parser.nbest_parse(sent):
    print t
[out]:

======= Kim arrived =========
(S (VP (NP Kim) (V arrived)))

======= Kim arrived or Dana left =========
(S (CP (VP (NP Kim) (V arrived)) (C or) (VP (NP Dana) (V left))))

=== Kim arrived or Dana left and everyone cheered ====
(S
  (CP
    (CP (VP (NP Kim) (V arrived)) (C or) (VP (NP Dana) (V left)))
    (C and)
    (VP (NP everyone) (V cheered))))
(S
  (CP
    (VP (NP Kim) (V arrived))
    (C or)
    (CP
      (VP (NP Dana) (V left))
      (C and)
      (VP (NP everyone) (V cheered)))))
. >>> import nltk
>>> groucho_grammar = nltk.parse_cfg("""
 S -> NP VP
NP -> N  V
N -> "Kim"
V -> "arrived"
VP -> NP VP
NP -> P  NP
P -> "or"
NP -> N V
N -> "Dana"
V -> "left"
VP -> P NP
P -> "and"
NP -> N V
N -> "everyone"
V -> "cheered"
""")
>>> sent = "Kim arrived or Dana left and everyone cheered".split()
>>> parser = nltk.ChartParser(groucho_grammar)
>>> trees = parser.nbest_parse(sent)
>>> for tree in trees:
tree.draw()

#2. В класі Tree реалізовано різноманітні корисні методи. Переглянути файл допомоги  Tree з документації та описати основні з цих методів (import Tree,  help(Tree).
from nltk import Tree
help(Tree)
print '''A Tree represents a hierarchical grouping of leaves and subtrees. A tree's children are encoded as a list of leaves and subtrees,where a leaf is a basic (non-tree) value; and a subtree is a nested Tree.
chomsky_normal_form(self, factor='right', horzMarkov=None, vertMarkov=0, childChar='|', parentChar='^')'''

#4. Перетворити всі дерева , які зустрічаються в методичних вказівка і зображені за допомогою дужок використовуючи  nltk.Tree() . Використовувати draw() для побудови графічного зображення дерева.
groucho_grammar = nltk.parse_cfg("""
S -> NP VP
PP -> P NP
NP -> Det N | Det N PP | 'I'
VP -> V NP | VP PP
Det -> 'an' | 'my'
N -> 'elephant' | 'pajamas'
V -> 'shot'
P -> 'in'
""")
sent = ['I', 'shot', 'an', 'elephant', 'in', 'my', 'pajamas']
parser = nltk.ChartParser(groucho_grammar)
trees = parser.nbest_parse(sent)
for tree in trees:
    tree.draw()
grammar1 = nltk.parse_cfg("""
S -> NP VP
VP -> V NP | V NP PP
PP -> P NP
V -> "saw" | "ate" | "walked"
NP -> "John" | "Mary" | "Bob" | Det N | Det N PP
Det -> "a" | "an" | "the" | "my"
N -> "man" | "dog" | "cat" | "telescope" | "park"
P -> "in" | "on" | "by" | "with"
""")
sent = "Mary saw Bob".split()
rd_parser = nltk.RecursiveDescentParser(grammar1)
for tree in rd_parser.nbest_parse(sent):
    tree.draw()
grammar2 = nltk.parse_cfg("""
S  -> NP VP
NP -> Det Nom | PropN
Nom -> Adj Nom | N
VP -> V Adj | V NP | V S | V NP PP
PP -> P NP
PropN -> 'Buster' | 'Chatterer' | 'Joe'
Det -> 'the' | 'a'
N -> 'bear' | 'squirrel' | 'tree' | 'fish' | 'log'
Adj  -> 'angry' | 'frightened' |  'little' | 'tall'
V ->  'chased'  | 'saw' | 'said' | 'thought' | 'was' | 'put'
P -> 'on'
""")
sent = "the angry bear chased the frightened little squirrel ".split()
parser = nltk.ChartParser(grammar2)
trees = parser.nbest_parse(sent)
for tree in trees:
    tree.draw()
#8. Написати програму для пошуку відповіді на питання.
#Чи може grammar1 граматика використовуватися для опису речення довжиною більше ніж 20 слів?
sr_parse = nltk.ShiftReduceParser(grammar1, trace=2)
print sr_parse.parse(sent)
sr_parse = nltk.ShiftReduceParser(grammar1)
print sr_parse.parse(sent)
for p in grammar1.productions():
	print p
import nltk.draw.rdparser
nltk.draw.rdparser.demo()
nltk.draw.srparser.demo()

#10. Здійснити аналіз послідовності слів: Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo.
#Оскільки, згідно з http://en.wikipedia.org/wiki/Buffalo_buffalo_Buffalo_buffalo_buffalo_buffalo_Buffalo_buffalo це граматично правильне речення, напишіть контексно-вільну граматику на основі дерева наведеного на цій сторінці з Інтернету.
#Здійсніть нормалізацію слів (lowercase), для моделювання ситуації коли слухач сприймає це речення на слух.
#Скільки дерев розбору може мати це дерево в такому випадку?
Buffalo_grammar = nltk.parse_cfg("""
S -> NP VP
NP -> NP RC | PN N
VP -> V NP
RC -> NP V
PN -> 'Buffalo'
N -> 'buffalo'
V -> 'buffalo'
""")
sent = "Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo".split()
parser = nltk.ChartParser(Buffalo_grammar)
trees = parser.nbest_parse(sent)
for tree in trees:
    tree.draw()
r="Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo"
print r.lower()
a=r.lower()
b=a.split()
for tree in rd_parser.nbest_parse(b):
	print tree
#12. Написати програму порівняння швидкодії всіх аналізаторів, які згадувалися в методичних.
#Використовувати timeit функцію для визначення часу синтаксичного аналізу одного і того самого речення різними аналізаторами.
rd_parser = nltk.RecursiveDescentParser(grammar1)
sr_parser = nltk.ShiftReduceParser(grammar1)
sent1 = "Mary saw Bob".split(
def timeit(sent1,parser):
    import time
    start=time.clock()
    print parser.parse(sent1)
    return time.clock()-start
timeit(sent1,rd_parser)
timeit(sent1,sr_parser)
import timeit
t1 = timeit.Timer(setup='from nltk import RecursiveDescentParser ')
t1.timeit()
t2 = timeit.Timer(setup='from nltk import ShiftReduceParser')
t2.timeit()
