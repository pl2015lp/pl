завдання 1 Дослідити зв’язки голонім-меронім для іменників. Знайти іменники для
 демонстрації наступних зв’язків: member_meronyms(), part_meronyms(), 
substance_meronyms(), member_holonyms(), part_holonyms(), та 
substance_holonyms().

from nltk.corpus import wordnet as wn
a = wn.synset('government.n.01').member_meronyms()
print a
b = wn.synset('tree.n.01').part_meronyms()
print b
c = wn.synset('coffee.n.01').substance_meronyms()
print c
d = wn.synset('flower.n.01').member_holonyms()
print d
f = wn.synset('finger.n.01').part_holonyms()
print f
ff = wn.synset('water.n.01').substance_holonyms()
print ff

завдання 3 Побудувати умовний частотний розподіл для корпусу імен. 
Знайти які перші літери частіше використовуються в чоловічих та жіночих іменах.

import nltk
from nltk.corpus import names
genders = ["male.txt", "female.txt"]
alphabets = ["A", "B", "C", "D", "E", "F", "G","H", "I", "J", "K", "L", "M", "N", "O", "P","Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
cfd = nltk.ConditionalFreqDist(
    (gender, firstletter)
for gender in genders
    for firstletter in alphabets
    for letter_count in
    [len(w) for w in names.words(gender)
    if w[0:1] == firstletter])
cfd.tabulate()
print 

завдання 6 Визначити функцію supergloss(s) , яка буде приймати синсет s як аргумент і повертати 
стрічку в якій будуть поєднані всі описи всіх значень синсету s та описи 
всіх  гіпернімів та гіпонімів s.

import nltk
from nltk.corpus import wordnet as wn
def supergloss (meaning):
	s=[]
	s.append (wn.synset(meaning).definition)
	s.append ([word.definition for word in wn.synset(meaning).hypernyms()])
	s.append ([word.definition for word in wn.synset(meaning).hyponyms()])
	return s

print supergloss ('life.n.01')

завдання 7 Модифікувати програму генерації випадкового тексту для виконання наступного: 
зберігати можливі наступні слова у списку та вибирати їх за допомогою 
random.choice() попередньо виконавши import random.

import nltk
from nltk.book import text6
import random
a=text6
print ('The text: ', a,'.\n')
word=[]
for i in range (20):
     word.append (random.choice(a))
     print (word)

завдання 10 10.	Полісемія - це явище коли одне слово має декілька значень 
( іменник dog має 7 значень, кількість яких визначити можна як 
len(wn.synsets('dog', 'n'))). Знайдіть середнє значення полісемії для іменників.

from __future__ import division
import nltk
from nltk.corpus import wordnet as wn
noun_meanings = []
for i in wn.all_synsets ('n'):
    for j in i.lemma_names:
        noun_meanings.append (j)
nouns_different = len (set (noun_meanings))
print (nouns_different)
noun_words = 0
for k in set (noun_meanings):
    noun_words = noun_words + len (wn.synsets (k, 'n'))
print (noun_words)
noun_poly= noun_words/nouns_different
print (noun_poly)

завдання 14 Використовуючи один з методів визначення подібності слів побудуйте 
відсортований по спаданню список значень подібності для наступних пар слів: 
car-automobile, gem-jewel, journey-voyage, boy-lad, coast-shore, asylum-madhouse,
 magician-wizard, midday-noon, furnace-stove, food-fruit, bird-cock.

from nltk.corpus import wordnet as wn
car=wn.synset('car.n.01')
automobile=wn.synset('automobile.n.01')
a=automobile.path_similarity(car)
print a

gem=wn.synset('gem.n.01')
jewel=wn.synset('jewel.n.01')
b=jewel.path_similarity(gem)
print b

journey=wn.synset('journey.n.01')
voyage=wn.synset('voyage.n.01')
c=voyage.path_similarity(journey)
print c

boy=wn.synset('boy.n.01')
lad=wn.synset('lad.n.01')
d=lad.path_similarity(boy)
print d

coast=wn.synset('coast.n.01')
shore=wn.synset('shore.n.01')
e=shore.path_similarity(coast)
print e

asylum=wn.synset('asylum.n.01')
madhouse=wn.synset('madhouse.n.01')
f=madhouse.path_similarity(asylum)
print f

magician=wn.synset('magician.n.01')
wizard=wn.synset('wizard.n.01')
g= wizard.path_similarity(magician)
print g

midday=wn.synset('midday.n.01')
noon=wn.synset('noon.n.01')
h=noon.path_similarity(midday)
print h

furnace=wn.synset('furnace.n.01')
stove=wn.synset('stove.n.01')
i=stove.path_similarity(furnace)
print i

food=wn.synset('food.n.01')
fruit=wn.synset('fruit.n.01')
j=fruit.path_similarity(food)
print j

bird=wn.synset('bird.n.01')
cock=wn.synset('cock.n.01')
k=cock.path_similarity(bird)
print k
s=[]
s.append(a)
s.append(b)
s.append(c)
s.append(d)
s.append(e)
s.append(f)
s.append(g)
s.append(h)
s.append(i)
s.append(j)
s.append(k)
print s
s.sort()
print 'sortovane po zrostanniu'
print s
s.reverse()
print 'sortovane po spadanniu'
print s
